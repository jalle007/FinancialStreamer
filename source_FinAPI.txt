# Folder Structure: d:\Projects\TESTS\FinAPI
# File: d:\Projects\TESTS\FinAPI\source-output.py
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\appsettings.Development.json
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\appsettings.json
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\Program.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\Controllers\PricesController.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\Properties\launchSettings.json
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Core\Interfaces\IPriceDataProvider.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Core\Models\FinancialInstrument.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Core\Models\PriceUpdate.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Infrastructure\Configurations\TiingoSettings.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Infrastructure\Services\TiingoPriceDataProvider.cs
# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.WebSocket\WebSocketHandler.cs


# File: d:\Projects\TESTS\FinAPI\source-output.py
#------------------------------------
import os
import argparse

def process_code_file(file_path, output_file, code_extensions):
    # Function to process individual code files
    if not file_path.endswith(tuple(code_extensions)):
        return

    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        content = file.read()

    header = f"\n# File: {file_path}\n#------------------------------------\n"

    output_file.write(header + content + '\n')

def main(target_folder):
    # Main function
    src_path = os.getcwd() if target_folder is None else target_folder
    parent_folder = os.path.basename(src_path)

    ignore_dirs = ['.git', 'bin', 'obj', 'node_modules', '.vs', '.idea', '.vscode', 'e2e', 'platforms', 'plugins', 'resources', 'www', '.nuget', 'packages', 'content', '.angular', '.firebase', '.github', '.VSCodeCounter',
                   '.angular', '.firebase', 'android', 'assets', '.gradle', '.sourcemaps'
                   ]

    ignore_files = {'package-lock.json', 'src-archive.py'}  # Using a set for faster lookup

    max_size = 1 * 1024 * 1024  # Maximum file size in bytes (1 MB)

    # Common code extensions for C#, Ionic, Angular, and Python projects
    # Common code extensions for C#, Ionic, Angular, Python, and Laravel projects
    code_extensions = ['.cs', '.js', '.ts', '.py', '.html', '.css', '.scss', '.sass', '.less', '.xml', '.json', '.yaml', '.yml', '.sql', '.php', '.blade.php']


    file_list = []  # List to store file paths

    with open(f'source_{parent_folder}.txt', 'w', encoding='utf-8', errors='ignore') as output_file:
        # Write folder structure to the top of the output file
        output_file.write(f"# Folder Structure: {src_path}\n")

        # Write individual file paths
        for root, dirs, files in os.walk(src_path):
            dirs[:] = [d for d in dirs if d not in ignore_dirs]
            for file in files:
                file_path = os.path.join(root, file)
                file_ext = os.path.splitext(file)[1]
                if (file_ext in code_extensions and
                        file not in ignore_files and
                        os.path.getsize(file_path) <= max_size):
                    file_list.append(file_path)

        # Write file list to the top of the output file
        for file_path in file_list:
            output_file.write(f"# File: {file_path}\n")

        # Add newline after file list
        output_file.write('\n')

        # Process individual code files
        for file_path in file_list:
            process_code_file(file_path, output_file, code_extensions)

    print(f'Successfully created source text file: source_{parent_folder}.txt')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Archive source code.')
    parser.add_argument('target_folder', type=str, nargs='?', help='The target folder to archive. If not provided, the current directory is used.')
    args = parser.parse_args()
    main(args.target_folder)


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\appsettings.Development.json
#------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\appsettings.json
#------------------------------------
{
  "Tiingo": {
    "ApiKey": "39d340eecbdc792d58a8111e7f6eecae4a194eda"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\Program.cs
#------------------------------------
using FinancialStreamer.Core.Interfaces;
using FinancialStreamer.Infrastructure.Configurations;
using FinancialStreamer.Infrastructure.Services;
using Microsoft.AspNetCore.WebSockets;
using FinancialStreamer.WebSocket;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddControllers();

// Add configuration
builder.Services.Configure<TiingoSettings>(builder.Configuration.GetSection("Tiingo"));
builder.Services.AddSingleton<IPriceDataProvider, TiingoPriceDataProvider>();
builder.Services.AddSingleton<WebSocketHandler>();

// Add WebSocket services
builder.Services.AddWebSockets(options => { });

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

// Configure WebSocket endpoint
app.UseWebSockets();
app.MapGet("/ws", async context =>
{
    if (context.WebSockets.IsWebSocketRequest)
    {
        var webSocket = await context.WebSockets.AcceptWebSocketAsync();
        var webSocketHandler = app.Services.GetRequiredService<WebSocketHandler>();
        await webSocketHandler.HandleWebSocketAsync(webSocket);
    }
    else
    {
        context.Response.StatusCode = 400;
    }
});

app.MapControllers();

app.Run();

 


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\Controllers\PricesController.cs
#------------------------------------
﻿using FinancialStreamer.Core.Interfaces;
using FinancialStreamer.Core.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace FinancialStreamer.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class PricesController : ControllerBase
    {
        private readonly IPriceDataProvider _priceDataProvider;
        private readonly ILogger<PricesController> _logger;

        public PricesController(IPriceDataProvider priceDataProvider, ILogger<PricesController> logger)
        {
            _priceDataProvider = priceDataProvider;
            _logger = logger;
        }

        [HttpGet("instruments")]
        public async Task<ActionResult<IEnumerable<FinancialInstrument>>> GetInstruments()
        {
            _logger.LogInformation("Fetching list of available financial instruments");
            var instruments = await _priceDataProvider.GetInstrumentsAsync();
            return Ok(instruments);
        }

        [HttpGet("{symbol}")]
        public async Task<ActionResult<PriceUpdate>> GetPrice(string symbol)
        {
            _logger.LogInformation($"Fetching current price for {symbol}");
            var price = await _priceDataProvider.GetPriceAsync(symbol);
            if (price == null)
            {
                _logger.LogWarning($"No price data available for {symbol}");
                return NotFound();
            }
            return Ok(price);
        }
    }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Api\Properties\launchSettings.json
#------------------------------------
﻿{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:16059",
      "sslPort": 44380
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5201",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7057;http://localhost:5201",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Core\Interfaces\IPriceDataProvider.cs
#------------------------------------
﻿using FinancialStreamer.Core.Models;

namespace FinancialStreamer.Core.Interfaces
{
    public interface IPriceDataProvider
    {
        Task<IEnumerable<FinancialInstrument>> GetInstrumentsAsync();
        Task<PriceUpdate?> GetPriceAsync(string symbol);
        Task SubscribeToPriceUpdatesAsync(string symbol, Action<PriceUpdate> onUpdate);
    }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Core\Models\FinancialInstrument.cs
#------------------------------------
﻿namespace FinancialStreamer.Core.Models
{
    public class FinancialInstrument
    {
        public string Symbol { get; set; }
        public string Name { get; set; }
    }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Core\Models\PriceUpdate.cs
#------------------------------------
﻿namespace FinancialStreamer.Core.Models
{
    public class PriceUpdate
    {
        public string Symbol { get; set; }
        public double? Price { get; set; }
        public DateTime? Timestamp { get; set; }
    }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Infrastructure\Configurations\TiingoSettings.cs
#------------------------------------
﻿namespace FinancialStreamer.Infrastructure.Configurations
{
    public class TiingoSettings
    {
        public string ApiKey { get; set; }
    }
}


# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.Infrastructure\Services\TiingoPriceDataProvider.cs
#------------------------------------
﻿using FinancialStreamer.Core.Interfaces;
using FinancialStreamer.Core.Models;
using FinancialStreamer.Infrastructure.Configurations;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Restless.Tiingo.Core;
using Restless.Tiingo.Data;
using Restless.Tiingo.Socket.Data;

namespace FinancialStreamer.Infrastructure.Services
{ 
public class TiingoPriceDataProvider : IPriceDataProvider
{
    private readonly Restless.Tiingo.Client.TiingoClient _restClient;
    private readonly Restless.Tiingo.Socket.Client.TiingoClient _socketClient;
    private readonly ILogger<TiingoPriceDataProvider> _logger;
    private readonly TiingoSettings _settings;

    public TiingoPriceDataProvider(IOptions<TiingoSettings> settings, ILogger<TiingoPriceDataProvider> logger)
    {
        _settings = settings.Value;
        _restClient = Restless.Tiingo.Client.TiingoClient.Create(_settings.ApiKey);
        _socketClient = Restless.Tiingo.Socket.Client.TiingoClient.Create(_settings.ApiKey);
        _logger = logger;
    }

    public async Task<IEnumerable<FinancialInstrument>> GetInstrumentsAsync()
    {
        _logger.LogInformation("Fetching list of available financial instruments");
        var forexPairs = await _restClient.Forex.GetSupportedSymbolPairsAsync();
        return forexPairs.Select(item => new FinancialInstrument
        {
            Symbol = item.Ticker,
            Name = $"{item.BaseCurrency}/{item.QuoteCurrency}"
        });
    }

    public async Task<PriceUpdate?> GetPriceAsync(string symbol)
    {
        _logger.LogInformation($"Fetching price for {symbol}");
        var forexData = await _restClient.Forex.GetDataPointsAsync(new Restless.Tiingo.Core.ForexParameters
        {
            Tickers = new[] { new TickerPair(symbol.Substring(0, 3), symbol.Substring(3, 3)) },
            StartDate = DateTime.UtcNow.AddDays(-1),
            Frequency = FrequencyUnit.Day,
            FrequencyValue = 1
        });

        var latestData = forexData.LastOrDefault();
        if (latestData == null)
        {
            _logger.LogWarning($"No data available for {symbol}");
            return null;
        }

        var priceUpdate = new PriceUpdate
        {
            Symbol = symbol,
            Price = latestData.Close,
            Timestamp = latestData.Date
        };

        _logger.LogInformation($"Fetched price for {symbol}: {priceUpdate.Price} at {priceUpdate.Timestamp}");
        return priceUpdate;
    }

    public async Task SubscribeToPriceUpdatesAsync(string symbol, Action<PriceUpdate> onUpdate)
    {
        _logger.LogInformation($"Subscribing to price updates for {symbol}");
        await _socketClient.Forex.GetAsync(new Restless.Tiingo.Socket.Core.ForexParameters
        {
            Tickers = new[] { symbol }
        }, result =>
        {
            if (result is ForexQuoteMessage quote)
            {
                var priceUpdate = new PriceUpdate
                {
                    Symbol = quote.Ticker,
                    Price = quote.MidPrice,
                    Timestamp = quote.Timestamp
                };

                _logger.LogInformation($"Received price update for {symbol}: {priceUpdate.Price} at {priceUpdate.Timestamp}");
                onUpdate(priceUpdate);
            }
        });
    }
}

}

# File: d:\Projects\TESTS\FinAPI\FinancialStreamer.WebSocket\WebSocketHandler.cs
#------------------------------------
﻿using FinancialStreamer.Core.Interfaces;
using FinancialStreamer.Core.Models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.WebSockets;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace FinancialStreamer.WebSocket
{
    public class WebSocketHandler
    {
        private static readonly Dictionary<string, List<System.Net.WebSockets.WebSocket>> _subscribers = new Dictionary<string, List<System.Net.WebSockets.WebSocket>>();
        private static readonly SemaphoreSlim _subscribersLock = new SemaphoreSlim(1, 1);
        private readonly IPriceDataProvider _priceDataProvider;
        private readonly ILogger<WebSocketHandler> _logger;

        public WebSocketHandler(IPriceDataProvider priceDataProvider, ILogger<WebSocketHandler> logger)
        {
            _priceDataProvider = priceDataProvider;
            _logger = logger;
        }

        public async Task HandleWebSocketAsync(System.Net.WebSockets.WebSocket webSocket)
        {
            try
            {
                while (webSocket.State == WebSocketState.Open)
                {
                    var buffer = new byte[1024 * 4];
                    var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

                    if (result.MessageType == WebSocketMessageType.Close)
                    {
                        await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closed by the WebSocket client", CancellationToken.None);
                        return;
                    }

                    // Convert the buffer to a string
                    var messageJson = System.Text.Encoding.UTF8.GetString(buffer, 0, result.Count);
                    _logger.LogInformation($"Received raw message: {messageJson}");

                    // Deserialize the message
                    var message = JsonSerializer.Deserialize<WebSocketMessage>(messageJson);
                    _logger.LogInformation($"Deserialized message: Method={message?.Method}, Params={string.Join(",", message?.Params ?? new List<string>())}");

                    if (message?.Method == "SUBSCRIBE")
                    {
                        foreach (var symbol in message.Params)
                        {
                            _logger.LogInformation($"Subscribing to {symbol}");
                            await AddSubscriberAsync(symbol, webSocket);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "WebSocket error");
            }
        }

        private async Task AddSubscriberAsync(string symbol, System.Net.WebSockets.WebSocket webSocket)
        {
            await _subscribersLock.WaitAsync();
            try
            {
                if (!_subscribers.ContainsKey(symbol))
                {
                    _subscribers[symbol] = new List<System.Net.WebSockets.WebSocket>();
                    _logger.LogInformation($"Creating new subscriber list for {symbol}");
                    await _priceDataProvider.SubscribeToPriceUpdatesAsync(symbol, async priceUpdate =>
                    {
                        await BroadcastPriceUpdateAsync(symbol, priceUpdate);
                    });
                }

                _subscribers[symbol].Add(webSocket);
                _logger.LogInformation($"Added subscriber for {symbol}");
            }
            finally
            {
                _subscribersLock.Release();
            }
        }

        private async Task BroadcastPriceUpdateAsync(string symbol, PriceUpdate priceUpdate)
        {
            await _subscribersLock.WaitAsync();
            try
            {
                if (_subscribers.TryGetValue(symbol, out var subscribers))
                {
                    var message = JsonSerializer.Serialize(priceUpdate);
                    var messageBytes = new ArraySegment<byte>(System.Text.Encoding.UTF8.GetBytes(message));
                    _logger.LogInformation($"Broadcasting price update for {symbol}: {message}");

                    foreach (var subscriber in subscribers.ToList())
                    {
                        if (subscriber.State == WebSocketState.Open)
                        {
                            await subscriber.SendAsync(messageBytes, WebSocketMessageType.Text, true, CancellationToken.None);
                        }
                        else
                        {
                            subscribers.Remove(subscriber);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error broadcasting price update for {symbol}");
            }
            finally
            {
                _subscribersLock.Release();
            }
        }

        private class WebSocketMessage
        {
            public string Method { get; set; }
            public List<string> Params { get; set; }
        }
    }
}

